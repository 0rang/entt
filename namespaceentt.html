<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">entt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="namespaceentt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__alias__t.html">as_alias_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as alias</em> policy.  <a href="structentt_1_1as__alias__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="structentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="structentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__actor.html">basic_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated to those who aren't confident with the entity-component-system architecture.  <a href="structentt_1_1basic__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector.html">basic_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html">basic_collector&lt; matcher&lt; type_list&lt; Reject... &gt;, type_list&lt; Require... &gt;, Rule... &gt;, Other... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_4.html">basic_collector&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt;, Owned... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__observer.html">basic_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer.  <a href="classentt_1_1basic__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01std_1_1enable__if__t_3_01ENTT__ENABLE__ETO_07Type_08_4_01_4.html">basic_storage&lt; Entity, Type, std::enable_if_t&lt; ENTT_ENABLE_ETO(Type)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01std_1_1enable__if__t_3_01ENTT__ENABLE__ETO_07Type_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View.  <a href="classentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html">basic_view&lt; Entity, exclude_t&lt; Exclude... &gt;, Component... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi component view.  <a href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html">basic_view&lt; Entity, exclude_t&lt;&gt;, Component &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single component view specialization.  <a href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1cache.html">cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple cache for resources of a given type.  <a href="structentt_1_1cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wrap a function or a member of a specified type.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html">delegate&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members.  <a href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dispatcher.html">dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="structentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01std_1_1uint16__t_01_4.html">entt_traits&lt; std::uint16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for a 16 bits entity identifier.  <a href="structentt_1_1entt__traits_3_01std_1_1uint16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01std_1_1uint32__t_01_4.html">entt_traits&lt; std::uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for a 32 bits entity identifier.  <a href="structentt_1_1entt__traits_3_01std_1_1uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01std_1_1uint64__t_01_4.html">entt_traits&lt; std::uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for a 64 bits entity identifier.  <a href="structentt_1_1entt__traits_3_01std_1_1uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="structentt_1_1exclude__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1extended__meta__factory.html">extended_meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended meta factory to be used for reflection purposes.  <a href="classentt_1_1extended__meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1get__t.html">get_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed components.  <a href="structentt_1_1get__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1handle.html">handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared resource handle.  <a href="classentt_1_1handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1identifier.html">identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types identifiers.  <a href="classentt_1_1identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html">is_equality_comparable&lt; Type, std::void_t&lt; decltype(std::declval&lt; Type &gt;()==std::declval&lt; Type &gt;())&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__named__type.html">is_named_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type has a name. In all other cases, <code>value</code> is false.  <a href="structentt_1_1is__named__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__named__type_3_01Type_00_01std_1_1void__t_3_01named__type__traits__t_3_01std_1_268fa5a871b2de95e24d77c0786df19e.html">is_named_type&lt; Type, std::void_t&lt; named_type_traits_t&lt; std::decay_t&lt; Type &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type has a name. In all other cases, <code>value</code> is false.  <a href="structentt_1_1is__named__type_3_01Type_00_01std_1_1void__t_3_01named__type__traits__t_3_01std_1_268fa5a871b2de95e24d77c0786df19e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1loader.html">loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for resource loaders.  <a href="classentt_1_1loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1matcher.html">matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouping matcher.  <a href="structentt_1_1matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__base.html">meta_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta base classes.  <a href="structentt_1_1meta__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__conv.html">meta_conv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta conversion functions.  <a href="structentt_1_1meta__conv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta constructors.  <a href="structentt_1_1meta__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for a meta context.  <a href="structentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta data.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__dtor.html">meta_dtor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta destructors.  <a href="structentt_1_1meta__dtor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="classentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__prop.html">meta_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta properties of any type.  <a href="structentt_1_1meta__prop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for meta types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1named__type__traits.html">named_type_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class used mainly to push things across boundaries.  <a href="structentt_1_1named__type__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1named__type__traits_3_01const_01Type_01_4.html">named_type_traits&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization used to get rid of constness.  <a href="structentt_1_1named__type__traits_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1service__locator.html">service_locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="structentt_1_1service__locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html">sigh&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html">sink&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse set implementation.  <a href="classentt_1_1sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage.html">storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="structentt_1_1storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__size.html">type_list_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__size_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_size&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time number of elements in a type list.  <a href="structentt_1_1type__list__size_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_unique&lt; type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html">type_list_unique&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memItemLeft" align="right" valign="top"><a id="a8f9dd22ce26cd7913a294b3fd520649b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a8f9dd22ce26cd7913a294b3fd520649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2768719b1f5967caf5836b2656d0ed6"><td class="memItemLeft" align="right" valign="top"><a id="af2768719b1f5967caf5836b2656d0ed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:af2768719b1f5967caf5836b2656d0ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:af2768719b1f5967caf5836b2656d0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a546467a3662e9a915d5d519ad565e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">More...</a><br /></td></tr>
<tr class="separator:a546467a3662e9a915d5d519ad565e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a75a277a6037279d65cd3874b46ec7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">More...</a><br /></td></tr>
<tr class="separator:a75a277a6037279d65cd3874b46ec7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a1328e9f26407f68f4f814ab86ad6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a63a1328e9f26407f68f4f814ab86ad6f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a63a1328e9f26407f68f4f814ab86ad6f">named_type_traits_t</a> = typename <a class="el" href="structentt_1_1named__type__traits.html">named_type_traits</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a63a1328e9f26407f68f4f814ab86ad6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a63a1328e9f26407f68f4f814ab86ad6f">More...</a><br /></td></tr>
<tr class="separator:a63a1328e9f26407f68f4f814ab86ad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292643317d1dbb13e45824f757bd1086"><td class="memItemLeft" align="right" valign="top"><a id="a292643317d1dbb13e45824f757bd1086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a292643317d1dbb13e45824f757bd1086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a292643317d1dbb13e45824f757bd1086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memItemLeft" align="right" valign="top"><a id="a48dfbb2991c5a19c6e2578830f7e3eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a48dfbb2991c5a19c6e2578830f7e3eda">observer</a> = <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3effdbc1557d9b1ffaed77f843c5c2cd"><td class="memItemLeft" align="right" valign="top"><a id="a3effdbc1557d9b1ffaed77f843c5c2cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3effdbc1557d9b1ffaed77f843c5c2cd">actor</a> = <a class="el" href="structentt_1_1basic__actor.html">basic_actor</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a3effdbc1557d9b1ffaed77f843c5c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a3effdbc1557d9b1ffaed77f843c5c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80012f9fa628920a3507ae947704d447"><td class="memItemLeft" align="right" valign="top"><a id="a80012f9fa628920a3507ae947704d447"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a80012f9fa628920a3507ae947704d447">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a80012f9fa628920a3507ae947704d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a80012f9fa628920a3507ae947704d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e50fc296c4ea68183db332950b99f5"><td class="memItemLeft" align="right" valign="top"><a id="ae7e50fc296c4ea68183db332950b99f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae7e50fc296c4ea68183db332950b99f5">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:ae7e50fc296c4ea68183db332950b99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ae7e50fc296c4ea68183db332950b99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memItemLeft" align="right" valign="top"><a id="a37b5b489846f6f2a5d143db2b4aea5d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a37b5b489846f6f2a5d143db2b4aea5d0">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2118c00dea16193aee017d1408beb53"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:af2118c00dea16193aee017d1408beb53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2118c00dea16193aee017d1408beb53">view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; entity, Types... &gt;</td></tr>
<tr class="memdesc:af2118c00dea16193aee017d1408beb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#af2118c00dea16193aee017d1408beb53">More...</a><br /></td></tr>
<tr class="separator:af2118c00dea16193aee017d1408beb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d470a55d982d87388e899c322e9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a85d470a55d982d87388e899c322e9ddc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85d470a55d982d87388e899c322e9ddc">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; entity &gt;</td></tr>
<tr class="memdesc:a85d470a55d982d87388e899c322e9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a85d470a55d982d87388e899c322e9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010d1bbf234dbca47e6755fc278e36b5"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a010d1bbf234dbca47e6755fc278e36b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a010d1bbf234dbca47e6755fc278e36b5">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt; entity, Types... &gt;</td></tr>
<tr class="memdesc:a010d1bbf234dbca47e6755fc278e36b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a010d1bbf234dbca47e6755fc278e36b5">More...</a><br /></td></tr>
<tr class="separator:a010d1bbf234dbca47e6755fc278e36b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f264daab30d8e01b88536aa43fe0c28"><td class="memTemplParams" colspan="2">template&lt;ENTT_ID_TYPE Value&gt; </td></tr>
<tr class="memitem:a4f264daab30d8e01b88536aa43fe0c28"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f264daab30d8e01b88536aa43fe0c28">tag</a> = std::integral_constant&lt; ENTT_ID_TYPE, Value &gt;</td></tr>
<tr class="memdesc:a4f264daab30d8e01b88536aa43fe0c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to ease the assignment of tags to entities.  <a href="namespaceentt.html#a4f264daab30d8e01b88536aa43fe0c28">More...</a><br /></td></tr>
<tr class="separator:a4f264daab30d8e01b88536aa43fe0c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a32ab4306d014ba95869e88be161145b0"><td class="memTemplParams" colspan="2">template&lt;typename Char , std::size_t N&gt; </td></tr>
<tr class="memitem:a32ab4306d014ba95869e88be161145b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a32ab4306d014ba95869e88be161145b0">basic_hashed_string</a> (const Char(&amp;str)[N]) ENTT_NOEXCEPT -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:a32ab4306d014ba95869e88be161145b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a32ab4306d014ba95869e88be161145b0">More...</a><br /></td></tr>
<tr class="separator:a32ab4306d014ba95869e88be161145b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a211752d12273a08015c524133e27c3"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a1a211752d12273a08015c524133e27c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1a211752d12273a08015c524133e27c3">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a1a211752d12273a08015c524133e27c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a1a211752d12273a08015c524133e27c3">More...</a><br /></td></tr>
<tr class="separator:a1a211752d12273a08015c524133e27c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae289e7f5640bb43223901039346e5ce0"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Class &gt; </td></tr>
<tr class="memitem:ae289e7f5640bb43223901039346e5ce0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae289e7f5640bb43223901039346e5ce0">overload</a> (Type Class::*member) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ae289e7f5640bb43223901039346e5ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded member functions.  <a href="namespaceentt.html#ae289e7f5640bb43223901039346e5ce0">More...</a><br /></td></tr>
<tr class="separator:ae289e7f5640bb43223901039346e5ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33de87747dbfdef2a916f290d4f66836"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a33de87747dbfdef2a916f290d4f66836"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a33de87747dbfdef2a916f290d4f66836">overload</a> (Type *func) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a33de87747dbfdef2a916f290d4f66836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <a href="namespaceentt.html#a33de87747dbfdef2a916f290d4f66836">More...</a><br /></td></tr>
<tr class="separator:a33de87747dbfdef2a916f290d4f66836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3131bbda45993bd35a9d07db09e777"><td class="memTemplParams" colspan="2">template&lt;class... Type&gt; </td></tr>
<tr class="memitem:a4f3131bbda45993bd35a9d07db09e777"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f3131bbda45993bd35a9d07db09e777">overloaded</a> (Type...) -&gt; <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Type... &gt;</td></tr>
<tr class="memdesc:a4f3131bbda45993bd35a9d07db09e777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a4f3131bbda45993bd35a9d07db09e777">More...</a><br /></td></tr>
<tr class="separator:a4f3131bbda45993bd35a9d07db09e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eed5a712064c8979741cdd932c1676"><td class="memItemLeft" align="right" valign="top"><a id="a30eed5a712064c8979741cdd932c1676"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a30eed5a712064c8979741cdd932c1676">ENTT_OPAQUE_TYPE</a> (entity, ENTT_ID_TYPE)</td></tr>
<tr class="memdesc:a30eed5a712064c8979741cdd932c1676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a30eed5a712064c8979741cdd932c1676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fad46bc9a218fdab0d9e9f85b772c8"><td class="memItemLeft" align="right" valign="top"><a id="a96fad46bc9a218fdab0d9e9f85b772c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a96fad46bc9a218fdab0d9e9f85b772c8">ENTT_OPAQUE_TYPE</a> (component, ENTT_ID_TYPE)</td></tr>
<tr class="memdesc:a96fad46bc9a218fdab0d9e9f85b772c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a96fad46bc9a218fdab0d9e9f85b772c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fee75741468f7807d3d48dd807ee024"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a3fee75741468f7807d3d48dd807ee024"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3fee75741468f7807d3d48dd807ee024">as_view</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; false, Entity &gt;</td></tr>
<tr class="memdesc:a3fee75741468f7807d3d48dd807ee024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a3fee75741468f7807d3d48dd807ee024">More...</a><br /></td></tr>
<tr class="separator:a3fee75741468f7807d3d48dd807ee024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac314d83c9af1077857f01975f086bed"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:aac314d83c9af1077857f01975f086bed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aac314d83c9af1077857f01975f086bed">as_view</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; true, Entity &gt;</td></tr>
<tr class="memdesc:aac314d83c9af1077857f01975f086bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aac314d83c9af1077857f01975f086bed">More...</a><br /></td></tr>
<tr class="separator:aac314d83c9af1077857f01975f086bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609f31d6ab3f544ebf7d0413d007ead"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6609f31d6ab3f544ebf7d0413d007ead"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6609f31d6ab3f544ebf7d0413d007ead">as_group</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; false, Entity &gt;</td></tr>
<tr class="memdesc:a6609f31d6ab3f544ebf7d0413d007ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a6609f31d6ab3f544ebf7d0413d007ead">More...</a><br /></td></tr>
<tr class="separator:a6609f31d6ab3f544ebf7d0413d007ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fce796266ac507c9b0c193a70f51745"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a8fce796266ac507c9b0c193a70f51745"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8fce796266ac507c9b0c193a70f51745">as_group</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; true, Entity &gt;</td></tr>
<tr class="memdesc:a8fce796266ac507c9b0c193a70f51745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a8fce796266ac507c9b0c193a70f51745">More...</a><br /></td></tr>
<tr class="separator:a8fce796266ac507c9b0c193a70f51745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79e77dca50a2a5d78ce51db8a0a68e5"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ab79e77dca50a2a5d78ce51db8a0a68e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab79e77dca50a2a5d78ce51db8a0a68e5">meta</a> () ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ab79e77dca50a2a5d78ce51db8a0a68e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#ab79e77dca50a2a5d78ce51db8a0a68e5">More...</a><br /></td></tr>
<tr class="separator:ab79e77dca50a2a5d78ce51db8a0a68e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2129cb8668f5dcbc11854be6a4a0b6e5"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2129cb8668f5dcbc11854be6a4a0b6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2129cb8668f5dcbc11854be6a4a0b6e5">resolve</a> () ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a2129cb8668f5dcbc11854be6a4a0b6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#a2129cb8668f5dcbc11854be6a4a0b6e5">More...</a><br /></td></tr>
<tr class="separator:a2129cb8668f5dcbc11854be6a4a0b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2ff81413fa0bda15d1c0b69497cf62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afd2ff81413fa0bda15d1c0b69497cf62">resolve</a> (const ENTT_ID_TYPE <a class="el" href="classentt_1_1identifier.html">identifier</a>) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:afd2ff81413fa0bda15d1c0b69497cf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier.  <a href="namespaceentt.html#afd2ff81413fa0bda15d1c0b69497cf62">More...</a><br /></td></tr>
<tr class="separator:afd2ff81413fa0bda15d1c0b69497cf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a0a841795917ea4d906981bee83b7"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af04a0a841795917ea4d906981bee83b7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; Op, <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af04a0a841795917ea4d906981bee83b7">resolve</a> (Op op) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:af04a0a841795917ea4d906981bee83b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates all the reflected types.  <a href="namespaceentt.html#af04a0a841795917ea4d906981bee83b7">More...</a><br /></td></tr>
<tr class="separator:af04a0a841795917ea4d906981bee83b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7582fde7d0323ad068543d660116f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3e7582fde7d0323ad068543d660116f4">operator!=</a> (const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a3e7582fde7d0323ad068543d660116f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two containers differ in their content.  <a href="namespaceentt.html#a3e7582fde7d0323ad068543d660116f4">More...</a><br /></td></tr>
<tr class="separator:a3e7582fde7d0323ad068543d660116f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe07bfd01b0fac902d6d89a76b8b58fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abe07bfd01b0fac902d6d89a76b8b58fe">operator!=</a> (const <a class="el" href="structentt_1_1meta__prop.html">meta_prop</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__prop.html">meta_prop</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:abe07bfd01b0fac902d6d89a76b8b58fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#abe07bfd01b0fac902d6d89a76b8b58fe">More...</a><br /></td></tr>
<tr class="separator:abe07bfd01b0fac902d6d89a76b8b58fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633d6546a24a66cfba27ad3f8bdbbd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a633d6546a24a66cfba27ad3f8bdbbd30">operator!=</a> (const <a class="el" href="structentt_1_1meta__base.html">meta_base</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__base.html">meta_base</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a633d6546a24a66cfba27ad3f8bdbbd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#a633d6546a24a66cfba27ad3f8bdbbd30">More...</a><br /></td></tr>
<tr class="separator:a633d6546a24a66cfba27ad3f8bdbbd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0028b0d2edc4d7fd110069323d80f4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae0028b0d2edc4d7fd110069323d80f4b">operator!=</a> (const <a class="el" href="structentt_1_1meta__conv.html">meta_conv</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__conv.html">meta_conv</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ae0028b0d2edc4d7fd110069323d80f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#ae0028b0d2edc4d7fd110069323d80f4b">More...</a><br /></td></tr>
<tr class="separator:ae0028b0d2edc4d7fd110069323d80f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e03a0e2b4f0ed2bf7dd7635e4d22e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a42e03a0e2b4f0ed2bf7dd7635e4d22e8">operator!=</a> (const <a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a42e03a0e2b4f0ed2bf7dd7635e4d22e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#a42e03a0e2b4f0ed2bf7dd7635e4d22e8">More...</a><br /></td></tr>
<tr class="separator:a42e03a0e2b4f0ed2bf7dd7635e4d22e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ba1bf1f3ad09a47b477ad9a320393f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab4ba1bf1f3ad09a47b477ad9a320393f">operator!=</a> (const <a class="el" href="structentt_1_1meta__dtor.html">meta_dtor</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__dtor.html">meta_dtor</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ab4ba1bf1f3ad09a47b477ad9a320393f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#ab4ba1bf1f3ad09a47b477ad9a320393f">More...</a><br /></td></tr>
<tr class="separator:ab4ba1bf1f3ad09a47b477ad9a320393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe04587aa936ef68791af1d99d380d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afffe04587aa936ef68791af1d99d380d">operator!=</a> (const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:afffe04587aa936ef68791af1d99d380d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#afffe04587aa936ef68791af1d99d380d">More...</a><br /></td></tr>
<tr class="separator:afffe04587aa936ef68791af1d99d380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccfeb5e95c4ce5ea82cac0b4738f49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0bccfeb5e95c4ce5ea82cac0b4738f49">operator!=</a> (const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;lhs, const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a0bccfeb5e95c4ce5ea82cac0b4738f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#a0bccfeb5e95c4ce5ea82cac0b4738f49">More...</a><br /></td></tr>
<tr class="separator:a0bccfeb5e95c4ce5ea82cac0b4738f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb1b10f84534d2ed32aed30c36cb61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2feb1b10f84534d2ed32aed30c36cb61">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a2feb1b10f84534d2ed32aed30c36cb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two meta objects refer to the same node.  <a href="namespaceentt.html#a2feb1b10f84534d2ed32aed30c36cb61">More...</a><br /></td></tr>
<tr class="separator:a2feb1b10f84534d2ed32aed30c36cb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656b2ec80abf493ce1924b314d13fd18"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:a656b2ec80abf493ce1924b314d13fd18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a656b2ec80abf493ce1924b314d13fd18">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a656b2ec80abf493ce1924b314d13fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <a href="namespaceentt.html#a656b2ec80abf493ce1924b314d13fd18">More...</a><br /></td></tr>
<tr class="separator:a656b2ec80abf493ce1924b314d13fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464a269b63d8c76395b0c54f33d3d6fb"><td class="memTemplParams" colspan="2">template&lt;auto Function&gt; </td></tr>
<tr class="memitem:a464a269b63d8c76395b0c54f33d3d6fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a464a269b63d8c76395b0c54f33d3d6fb">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Function &gt;) ENTT_NOEXCEPT -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Function)&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a464a269b63d8c76395b0c54f33d3d6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a464a269b63d8c76395b0c54f33d3d6fb">More...</a><br /></td></tr>
<tr class="separator:a464a269b63d8c76395b0c54f33d3d6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aa16e80c9720d136758f070db799ef"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:ab2aa16e80c9720d136758f070db799ef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab2aa16e80c9720d136758f070db799ef">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Candidate), Type * &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ab2aa16e80c9720d136758f070db799ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ab2aa16e80c9720d136758f070db799ef">More...</a><br /></td></tr>
<tr class="separator:ab2aa16e80c9720d136758f070db799ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562674030295e4dfd8bdd47b4a332b80"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:a562674030295e4dfd8bdd47b4a332b80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a562674030295e4dfd8bdd47b4a332b80">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type *) ENTT_NOEXCEPT -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Candidate), Type * &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a562674030295e4dfd8bdd47b4a332b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a562674030295e4dfd8bdd47b4a332b80">More...</a><br /></td></tr>
<tr class="separator:a562674030295e4dfd8bdd47b4a332b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3f083c1335549a9cdfcfeb7779332d"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:a5f3f083c1335549a9cdfcfeb7779332d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5f3f083c1335549a9cdfcfeb7779332d">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;) ENTT_NOEXCEPT -&gt; <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:a5f3f083c1335549a9cdfcfeb7779332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a5f3f083c1335549a9cdfcfeb7779332d">More...</a><br /></td></tr>
<tr class="separator:a5f3f083c1335549a9cdfcfeb7779332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;ENTT_ID_TYPE Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> = {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">More...</a><br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <a href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">More...</a><br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9c0b65bfb15bb63c8389391be28eb5"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:a6a9c0b65bfb15bb63c8389391be28eb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6a9c0b65bfb15bb63c8389391be28eb5">type_list_size_v</a> = <a class="el" href="structentt_1_1type__list__size.html">type_list_size</a>&lt;List&gt;::value</td></tr>
<tr class="memdesc:a6a9c0b65bfb15bb63c8389391be28eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a6a9c0b65bfb15bb63c8389391be28eb5">More...</a><br /></td></tr>
<tr class="separator:a6a9c0b65bfb15bb63c8389391be28eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2c2c940fcfd655abaa24489471dad8"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aff2c2c940fcfd655abaa24489471dad8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aff2c2c940fcfd655abaa24489471dad8">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aff2c2c940fcfd655abaa24489471dad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aff2c2c940fcfd655abaa24489471dad8">More...</a><br /></td></tr>
<tr class="separator:aff2c2c940fcfd655abaa24489471dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb84576de3485174075a28f5357b20d"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aacb84576de3485174075a28f5357b20d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aacb84576de3485174075a28f5357b20d">named_type_traits_v</a> = <a class="el" href="structentt_1_1named__type__traits.html">named_type_traits</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aacb84576de3485174075a28f5357b20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aacb84576de3485174075a28f5357b20d">More...</a><br /></td></tr>
<tr class="separator:aacb84576de3485174075a28f5357b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab127297f5449d5c90bcef166a12c4358"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab127297f5449d5c90bcef166a12c4358"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab127297f5449d5c90bcef166a12c4358">is_named_type_v</a> = <a class="el" href="structentt_1_1is__named__type.html">is_named_type</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:ab127297f5449d5c90bcef166a12c4358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab127297f5449d5c90bcef166a12c4358">More...</a><br /></td></tr>
<tr class="separator:ab127297f5449d5c90bcef166a12c4358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588326af8f6f902a6c0b57d3f9fc6c17"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a588326af8f6f902a6c0b57d3f9fc6c17">null</a> = internal::null{}</td></tr>
<tr class="memdesc:a588326af8f6f902a6c0b57d3f9fc6c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <a href="namespaceentt.html#a588326af8f6f902a6c0b57d3f9fc6c17">More...</a><br /></td></tr>
<tr class="separator:a588326af8f6f902a6c0b57d3f9fc6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b073b774362fe800d9cce3542927a"><td class="memItemLeft" align="right" valign="top"><a id="aea8b073b774362fe800d9cce3542927a"></a>
constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">collector</a> {}</td></tr>
<tr class="memdesc:aea8b073b774362fe800d9cce3542927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template used to ease the definition of collectors. <br /></td></tr>
<tr class="separator:aea8b073b774362fe800d9cce3542927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <a href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">More...</a><br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed components.  <a href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">More...</a><br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb24e649324b83ebcf9dea9c970b1e2d"><td class="memItemLeft" align="right" valign="top"><a id="abb24e649324b83ebcf9dea9c970b1e2d"></a>
constexpr <a class="el" href="structentt_1_1as__alias__t.html">as_alias_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abb24e649324b83ebcf9dea9c970b1e2d">as_alias</a></td></tr>
<tr class="memdesc:abb24e649324b83ebcf9dea9c970b1e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag. <br /></td></tr>
<tr class="separator:abb24e649324b83ebcf9dea9c970b1e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplParams" colspan="2"><a id="af1e73acd6f3d892955819677dc2664b7"></a>
template&lt;auto Func&gt; </td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af1e73acd6f3d892955819677dc2664b7">connect_arg</a> {}</td></tr>
<tr class="memdesc:af1e73acd6f3d892955819677dc2664b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Used to wrap a function or a member of a specified type.">connect_arg_t</a> used to disambiguate calls. <br /></td></tr>
<tr class="separator:af1e73acd6f3d892955819677dc2664b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a010d1bbf234dbca47e6755fc278e36b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010d1bbf234dbca47e6755fc278e36b5">&#9670;&nbsp;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a010d1bbf234dbca47e6755fc278e36b5">entt::group</a> = typedef <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;entity, Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types of components iterated by the group. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00086">86</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a63a1328e9f26407f68f4f814ab86ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a1328e9f26407f68f4f814ab86ad6f">&#9670;&nbsp;</a></span>named_type_traits_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a63a1328e9f26407f68f4f814ab86ad6f">entt::named_type_traits_t</a> = typedef typename <a class="el" href="structentt_1_1named__type__traits.html">named_type_traits</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially named type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00192">192</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4f264daab30d8e01b88536aa43fe0c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f264daab30d8e01b88536aa43fe0c28">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ENTT_ID_TYPE Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a4f264daab30d8e01b88536aa43fe0c28">entt::tag</a> = typedef std::integral_constant&lt;ENTT_ID_TYPE, Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to ease the assignment of tags to entities. </p>
<p>If used in combination with hashed strings, it simplifies the assignment of tags to entities and the use of tags in general where a type would be required otherwise.<br  />
 As an example and where the user defined literal for hashed strings hasn't been changed: </p><div class="fragment"><div class="line"><a class="code" href="classentt_1_1basic__registry.html">entt::registry</a> <a class="code" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a>;</div>
<div class="line"><a class="code" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a>.assign&lt;<a class="code" href="namespaceentt.html#a4f264daab30d8e01b88536aa43fe0c28">entt::tag</a>&lt;<span class="stringliteral">&quot;enemy&quot;</span>_hs&gt;&gt;(entity);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Tags are empty components and therefore candidates for the empty component optimization.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>The numeric representation of an instance of hashed string. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00133">133</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a546467a3662e9a915d5d519ad565e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546467a3662e9a915d5d519ad565e801">&#9670;&nbsp;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">entt::type_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00110">110</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a75a277a6037279d65cd3874b46ec7166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a277a6037279d65cd3874b46ec7166">&#9670;&nbsp;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">entt::type_list_unique_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00147">147</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2118c00dea16193aee017d1408beb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2118c00dea16193aee017d1408beb53">&#9670;&nbsp;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2118c00dea16193aee017d1408beb53">entt::view</a> = typedef <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;entity, Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types of components iterated by the view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00076">76</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6609f31d6ab3f544ebf7d0413d007ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6609f31d6ab3f544ebf7d0413d007ead">&#9670;&nbsp;</a></span>as_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; false, Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fce796266ac507c9b0c193a70f51745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fce796266ac507c9b0c193a70f51745">&#9670;&nbsp;</a></span>as_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; true, Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fee75741468f7807d3d48dd807ee024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fee75741468f7807d3d48dd807ee024">&#9670;&nbsp;</a></span>as_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; false, Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac314d83c9af1077857f01975f086bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac314d83c9af1077857f01975f086bed">&#9670;&nbsp;</a></span>as_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; true, Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ab4306d014ba95869e88be161145b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ab4306d014ba95869e88be161145b0">&#9670;&nbsp;</a></span>basic_hashed_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the character type of the hashed string directly from a human-readable identifer provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2aa16e80c9720d136758f070db799ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aa16e80c9720d136758f070db799ef">&#9670;&nbsp;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Candidate), Type * &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of the delegate directly from a member or a free function with payload provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Member or free function to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a562674030295e4dfd8bdd47b4a332b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562674030295e4dfd8bdd47b4a332b80">&#9670;&nbsp;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Candidate), Type * &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of the delegate directly from a member or a free function with payload provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Member or free function to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a464a269b63d8c76395b0c54f33d3d6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464a269b63d8c76395b0c54f33d3d6fb">&#9670;&nbsp;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Function &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::to_function_pointer_t&lt; decltype(Function)&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of the delegate directly from a function provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>A valid free function pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab79e77dca50a2a5d78ce51db8a0a68e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79e77dca50a2a5d78ce51db8a0a68e5">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a>&lt;Type&gt; entt::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00815">815</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a1a211752d12273a08015c524133e27c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a211752d12273a08015c524133e27c3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00217">217</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a656b2ec80abf493ce1924b314d13fd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656b2ec80abf493ce1924b314d13fd18">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00308">308</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a3e7582fde7d0323ad068543d660116f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7582fde7d0323ad068543d660116f4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two containers differ in their content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta any object, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta any object, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two containers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00764">764</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a633d6546a24a66cfba27ad3f8bdbbd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633d6546a24a66cfba27ad3f8bdbbd30">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__base.html">meta_base</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__base.html">meta_base</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00873">873</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="ae0028b0d2edc4d7fd110069323d80f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0028b0d2edc4d7fd110069323d80f4b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__conv.html">meta_conv</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__conv.html">meta_conv</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00919">919</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a42e03a0e2b4f0ed2bf7dd7635e4d22e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e03a0e2b4f0ed2bf7dd7635e4d22e8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01016">1016</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="afffe04587aa936ef68791af1d99d380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffe04587aa936ef68791af1d99d380d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__data.html">meta_data</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01216">1216</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="ab4ba1bf1f3ad09a47b477ad9a320393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ba1bf1f3ad09a47b477ad9a320393f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__dtor.html">meta_dtor</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__dtor.html">meta_dtor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01064">1064</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a0bccfeb5e95c4ce5ea82cac0b4738f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bccfeb5e95c4ce5ea82cac0b4738f49">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__func.html">meta_func</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01349">1349</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="abe07bfd01b0fac902d6d89a76b8b58fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe07bfd01b0fac902d6d89a76b8b58fe">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__prop.html">meta_prop</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1meta__prop.html">meta_prop</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00824">824</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a2feb1b10f84534d2ed32aed30c36cb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb1b10f84534d2ed32aed30c36cb61">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two meta objects refer to the same node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two meta objects refer to the same node, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01767">1767</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a33de87747dbfdef2a916f290d4f66836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de87747dbfdef2a916f290d4f66836">&#9670;&nbsp;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00044">44</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ae289e7f5640bb43223901039346e5ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae289e7f5640bb43223901039346e5ce0">&#9670;&nbsp;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded member functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Function type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member functions belong. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00034">34</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a4f3131bbda45993bd35a9d07db09e777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3131bbda45993bd35a9d07db09e777">&#9670;&nbsp;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1overloaded.html">entt::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Type...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Type... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2129cb8668f5dcbc11854be6a4a0b6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2129cb8668f5dcbc11854be6a4a0b6e5">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00826">826</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="afd2ff81413fa0bda15d1c0b69497cf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2ff81413fa0bda15d1c0b69497cf62">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const ENTT_ID_TYPE&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00836">836</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="af04a0a841795917ea4d906981bee83b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04a0a841795917ea4d906981bee83b7">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;Op, <a class="el" href="classentt_1_1meta__type.html">meta_type</a>&gt;, void&gt; entt::resolve </td>
          <td>(</td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates all the reflected types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Type of the function object to invoke. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>A valid function object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00850">850</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a5f3f083c1335549a9cdfcfeb7779332d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3f083c1335549a9cdfcfeb7779332d">&#9670;&nbsp;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sink.html">entt::sink</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&nbsp;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00037">37</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&nbsp;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00024">24</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&nbsp;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00040">40</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aff2c2c940fcfd655abaa24489471dad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2c2c940fcfd655abaa24489471dad8">&#9670;&nbsp;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially equality comparable type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00169">169</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab127297f5449d5c90bcef166a12c4358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab127297f5449d5c90bcef166a12c4358">&#9670;&nbsp;</a></span>is_named_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_named_type_v = <a class="el" href="structentt_1_1is__named__type.html">is_named_type</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially named type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00222">222</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&nbsp;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ENTT_ID_TYPE Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00056">56</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="aacb84576de3485174075a28f5357b20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb84576de3485174075a28f5357b20d">&#9670;&nbsp;</a></span>named_type_traits_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::named_type_traits_v = <a class="el" href="structentt_1_1named__type__traits.html">named_type_traits</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially named type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00200">200</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a588326af8f6f902a6c0b57d3f9fc6c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588326af8f6f902a6c0b57d3f9fc6c17">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::null = internal::null{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p>TURN_OFF_DOXYGEN There exist implicit conversions from this variable to entity identifiers of any allowed type. Similarly, there exist comparision operators between the null entity and any other entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00168">168</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a6a9c0b65bfb15bb63c8389391be28eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9c0b65bfb15bb63c8389391be28eb5">&#9670;&nbsp;</a></span>type_list_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::type_list_size_v = <a class="el" href="structentt_1_1type__list__size.html">type_list_size</a>&lt;List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00065">65</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceentt_html_a292643317d1dbb13e45824f757bd1086"><div class="ttname"><a href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">entt::registry</a></div><div class="ttdeci">basic_registry&lt; entity &gt; registry</div><div class="ttdoc">Alias declaration for the most common use case.</div><div class="ttdef"><b>Definition:</b> <a href="entity_2fwd_8hpp_source.html#l00054">fwd.hpp:54</a></div></div>
<div class="ttc" id="anamespaceentt_html_a4f264daab30d8e01b88536aa43fe0c28"><div class="ttname"><a href="namespaceentt.html#a4f264daab30d8e01b88536aa43fe0c28">entt::tag</a></div><div class="ttdeci">std::integral_constant&lt; ENTT_ID_TYPE, Value &gt; tag</div><div class="ttdoc">Alias template to ease the assignment of tags to entities.</div><div class="ttdef"><b>Definition:</b> <a href="helper_8hpp_source.html#l00133">helper.hpp:133</a></div></div>
<div class="ttc" id="aclassentt_1_1basic__registry_html"><div class="ttname"><a href="classentt_1_1basic__registry.html">entt::basic_registry</a></div><div class="ttdoc">Fast and reliable entity-component system.</div><div class="ttdef"><b>Definition:</b> <a href="entity_2fwd_8hpp_source.html#l00013">fwd.hpp:13</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
