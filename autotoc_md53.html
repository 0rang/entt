<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Crash Course: events, signals and everything in between</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">2.7.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Crash Course: events, signals and everything in between </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md54"></a>
Introduction</h1>
<p>Signals are usually a core part of games and software architectures in general.<br />
 Roughly speaking, they help to decouple the various parts of a system while allowing them to communicate with each other somehow.</p>
<p>The so called _modern C++_ comes with a tool that can be useful in these terms, the <code>std::function</code>. As an example, it can be used to create delegates.<br />
 However, there is no guarantee that an <code>std::function</code> does not perform allocations under the hood and this could be problematic sometimes. Furthermore, it solves a problem but may not adapt well to other requirements that may arise from time to time.</p>
<p>In case that the flexibility and potential of an <code>std::function</code> are not required or where you are looking for something different, <code>EnTT</code> offers a full set of classes to solve completely different problems.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Signals</h1>
<p>Signal handlers work with naked pointers, function pointers and pointers to member functions. Listeners can be any kind of objects and users are in charge of connecting and disconnecting them from a signal to avoid crashes due to different lifetimes. On the other side, performance shouldn't be affected that much by the presence of such a signal handler.<br />
 A signal handler can be used as a private data member without exposing any <em>publish</em> functionality to the clients of a class. The basic idea is to impose a clear separation between the signal itself and its <em>sink</em> class, that is a tool to be used to connect and disconnect listeners on the fly.</p>
<p>The API of a signal handler is straightforward. The most important thing is that it comes in two forms: with and without a collector. In case a signal is associated with a collector, all the values returned by the listeners can be literally <em>collected</em> and used later by the caller. Otherwise it works just like a plain signal that emits events from time to time.<br />
</p>
<p><b>Note</b>: collectors are allowed only in case of function types whose the return type isn't <code>void</code> for obvious reasons.</p>
<p>To create instances of signal handlers there exist mainly two ways:</p>
<div class="fragment"><div class="line"><span class="comment">// no collector type</span></div><div class="line"><a class="code" href="classentt_1_1SigH.html">entt::SigH&lt;void(int, char)&gt;</a> signal;</div><div class="line"></div><div class="line"><span class="comment">// explicit collector type</span></div><div class="line"><a class="code" href="classentt_1_1SigH.html">entt::SigH&lt;void(int, char), MyCollector&lt;bool&gt;</a>&gt; collector;</div></div><!-- fragment --><p>As expected, they offer all the basic functionalities required to know how many listeners they contain (<code>size</code>) or if they contain at least a listener (<code>empty</code>) and even to swap two signal handlers (<code>swap</code>).</p>
<p>Besides them, there are member functions to use both to connect and disconnect listeners in all their forms by means of a sink:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>) { <span class="comment">/* ... */</span> }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>S {</div><div class="line">    <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>) { <span class="comment">/* ... */</span> }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">S instance;</div><div class="line"></div><div class="line">signal.sink().connect&lt;&amp;foo&gt;();</div><div class="line">signal.sink().connect&lt;S, &amp;S::bar&gt;(&amp;instance);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// disconnects a free function</span></div><div class="line">signal.sink().disconnect&lt;&amp;foo&gt;();</div><div class="line"></div><div class="line"><span class="comment">// disconnect a specific member function of an instance ...</span></div><div class="line">signal.sink().disconnect&lt;S, &amp;S::bar&gt;(&amp;instance);</div><div class="line"></div><div class="line"><span class="comment">// ... or an instance as a whole</span></div><div class="line">signal.sink().disconnect(&amp;instance);</div><div class="line"></div><div class="line"><span class="comment">// discards all the listeners at once</span></div><div class="line">signal.sink().disconnect();</div></div><!-- fragment --><p>Once listeners are attached (or even if there are no listeners at all), events and data in general can be published through a signal by means of the <code>publish</code> member function:</p>
<div class="fragment"><div class="line">signal.publish(42, <span class="charliteral">&#39;c&#39;</span>);</div></div><!-- fragment --><p>To collect data, the <code>collect</code> member function should be used instead. Below is a minimal example to show how to use it:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyCollector {</div><div class="line">    std::vector&lt;int&gt; vec{};</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> v) noexcept {</div><div class="line">        vec.push_back(v);</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; }</div><div class="line"><span class="keywordtype">int</span> g() { <span class="keywordflow">return</span> 1; }</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><a class="code" href="classentt_1_1SigH.html">entt::SigH&lt;int(), MyCollector&lt;int&gt;</a>&gt; signal;</div><div class="line"></div><div class="line">signal.sink().connect&lt;&amp;f&gt;();</div><div class="line">signal.sink().connect&lt;&amp;g&gt;();</div><div class="line"></div><div class="line">MyCollector collector = signal.collect();</div><div class="line"></div><div class="line">assert(collector.vec[0] == 0);</div><div class="line">assert(collector.vec[1] == 1);</div></div><!-- fragment --><p>As shown above, a collector must expose a function operator that accepts as an argument a type to which the return type of the listeners can be converted. Moreover, it has to return a boolean value that is false to stop collecting data, true otherwise. This way one can avoid calling all the listeners in case it isn't necessary.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Delegate</h1>
<p>A delegate can be used as general purpose invoker with no memory overhead for free functions and member functions provided along with an instance on which to invoke them.<br />
 It does not claim to be a drop-in replacement for an <code>std::function</code>, so do not expect to use it whenever an <code>std::function</code> fits well. However, it can be used to send opaque delegates around to be used to invoke functions as needed.</p>
<p>The interface is trivial. It offers a default constructor to create empty delegates:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1Delegate.html">entt::Delegate&lt;int(int)&gt;</a> delegate{};</div></div><!-- fragment --><p>All what is needed to create an instance is to specify the type of the function the delegate will <em>contain</em>, that is the signature of the free function or the member function one wants to assign to it.</p>
<p>Attempting to use an empty delegate by invoking its function call operator results in undefined behavior, most likely a crash actually. Before to use a delegate, it must be initialized.<br />
 There exist two functions to do that, both named <code>connect</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i; }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>MyStruct {</div><div class="line">    <span class="keywordtype">int</span> f(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// bind a free function to the delegate</span></div><div class="line">delegate.connect&lt;&amp;f&gt;();</div><div class="line"></div><div class="line"><span class="comment">// bind a member function to the delegate</span></div><div class="line">MyStruct instance;</div><div class="line">delegate.connect&lt;MyStruct, &amp;MyStruct::f&gt;(&amp;instance);</div></div><!-- fragment --><p>It hasn't a <code>disconnect</code> counterpart. Instead, there exists a <code>reset</code> member function to clear it.<br />
 The <code>empty</code> member function can be used to know if a delegate is empty:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> empty = delegate.empty();</div></div><!-- fragment --><p>Finally, to invoke a delegate, the function call operator is the way to go as usual:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ret = delegate(42);</div></div><!-- fragment --><p>Probably too much small and pretty poor of functionalities, but the delegate class can help in a lot of cases and it has shown that it is worth keeping it within the library.</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Event dispatcher</h1>
<p>The event dispatcher class is designed so as to be used in a loop. It allows users both to trigger immediate events or to queue events to be published all together once per tick.<br />
 This class shares part of its API with the one of the signal handler, but it doesn't require that all the types of events are specified when declared:</p>
<div class="fragment"><div class="line"><span class="comment">// define a general purpose dispatcher that works with naked pointers</span></div><div class="line"><a class="code" href="classentt_1_1Dispatcher.html">entt::Dispatcher</a> dispatcher{};</div></div><!-- fragment --><p>In order to register an instance of a class to a dispatcher, its type must expose one or more member functions of which the return types are <code>void</code> and the argument lists are <code>const E &amp;</code>, for each type of event <code>E</code>.<br />
 To ease the development, member functions that are named <code>receive</code> are automatically detected and have not to be explicitly specified when registered. In all the other cases, the name of the member function aimed to receive the event must be provided to the <code>connect</code> member function of the sink bound to the specific event:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AnEvent { <span class="keywordtype">int</span> value; };</div><div class="line"><span class="keyword">struct </span>AnotherEvent {};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Listener</div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> receive(<span class="keyword">const</span> AnEvent &amp;) { <span class="comment">/* ... */</span> }</div><div class="line">    <span class="keywordtype">void</span> method(<span class="keyword">const</span> AnotherEvent &amp;) { <span class="comment">/* ... */</span> }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">Listener listener;</div><div class="line">dispatcher.sink&lt;AnEvent&gt;().<a class="code" href="namespaceentt.html#a70059e6999fc2c4fa892b3a8afc4d8bc">connect</a>(&amp;listener);</div><div class="line">dispatcher.sink&lt;AnotherEvent&gt;().connect&lt;Listener, &amp;Listener::method&gt;(&amp;listener);</div></div><!-- fragment --><p>The <code>disconnect</code> member function follows the same pattern and can be used to selectively remove listeners:</p>
<div class="fragment"><div class="line">dispatcher.sink&lt;AnEvent&gt;().<a class="code" href="namespaceentt.html#a8232dd7b7bfb15a663db6dc55e502eb2">disconnect</a>(&amp;listener);</div><div class="line">dispatcher.sink&lt;AnotherEvent&gt;().disconnect&lt;Listener, &amp;Listener::method&gt;(&amp;listener);</div></div><!-- fragment --><p>The <code>trigger</code> member function serves the purpose of sending an immediate event to all the listeners registered so far. It offers a convenient approach that relieves users from having to create the event itself. Instead, it's enough to specify the type of event and provide all the parameters required to construct it.<br />
 As an example:</p>
<div class="fragment"><div class="line">dispatcher.trigger&lt;AnEvent&gt;(42);</div><div class="line">dispatcher.trigger&lt;AnotherEvent&gt;();</div></div><!-- fragment --><p>Listeners are invoked immediately, order of execution isn't guaranteed. This method can be used to push around urgent messages like an <em>is terminating</em> notification on a mobile app.</p>
<p>On the other hand, the <code>enqueue</code> member function queues messages together and allows to maintain control over the moment they are sent to listeners. The signature of this method is more or less the same of <code>trigger</code>:</p>
<div class="fragment"><div class="line">dispatcher.enqueue&lt;AnEvent&gt;(42);</div><div class="line">dispatcher.enqueue&lt;AnotherEvent&gt;();</div></div><!-- fragment --><p>Events are stored aside until the <code>update</code> member function is invoked, then all the messages that are still pending are sent to the listeners at once:</p>
<div class="fragment"><div class="line"><span class="comment">// emits all the events of the given type at once</span></div><div class="line">dispatcher.update&lt;MyEvent&gt;();</div><div class="line"></div><div class="line"><span class="comment">// emits all the events queued so far at once</span></div><div class="line">dispatcher.update();</div></div><!-- fragment --><p>This way users can embed the dispatcher in a loop and literally dispatch events once per tick to their systems.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Event emitter</h1>
<p>A general purpose event emitter thought mainly for those cases where it comes to working with asynchronous stuff.<br />
 Originally designed to fit the requirements of <a href="https://github.com/skypjack/uvw"><code>uvw</code></a> (a wrapper for <code>libuv</code> written in modern C++), it was adapted later to be included in this library.</p>
<p>To create a custom emitter type, derived classes must inherit directly from the base class as:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyEmitter: Emitter&lt;MyEmitter&gt; {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>The full list of accepted types of events isn't required. Handlers are created internally on the fly and thus each type of event is accepted by default.</p>
<p>Whenever an event is published, an emitter provides the listeners with a reference to itself along with a const reference to the event. Therefore listeners have an handy way to work with it without incurring in the need of capturing a reference to the emitter itself.<br />
 In addition, an opaque object is returned each time a connection is established between an emitter and a listener, allowing the caller to disconnect them at a later time.<br />
 The opaque object used to handle connections is both movable and copyable. On the other side, an event emitter is movable but not copyable by default.</p>
<p>To create new instances of an emitter, no arguments are required:</p>
<div class="fragment"><div class="line">MyEmitter emitter{};</div></div><!-- fragment --><p>Listeners must be movable and callable objects (free functions, lambdas, functors, <code>std::function</code>s, whatever) whose function type is:</p>
<div class="fragment"><div class="line">void(<span class="keyword">const</span> Event &amp;, MyEmitter &amp;)</div></div><!-- fragment --><p>Where <code>Event</code> is the type of event they want to listen.<br />
 There are two ways to attach a listener to an event emitter that differ slightly from each other:</p>
<ul>
<li>To register a long-lived listener, use the <code>on</code> member function. It is meant to register a listener designed to be invoked more than once for the given event type.<br />
 As an example:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> conn = emitter.on&lt;MyEvent&gt;([](<span class="keyword">const</span> MyEvent &amp;event, MyEmitter &amp;emitter) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>The connection object can be freely discarded. Otherwise, it can be used later to disconnect the listener if required.</p>
<ul>
<li>To register a short-lived listener, use the <code>once</code> member function. It is meant to register a listener designed to be invoked only once for the given event type. The listener is automatically disconnected after the first invocation.<br />
 As an example:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> conn = emitter.once&lt;MyEvent&gt;([](<span class="keyword">const</span> MyEvent &amp;event, MyEmitter &amp;emitter) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>The connection object can be freely discarded. Otherwise, it can be used later to disconnect the listener if required.</p>
<p>In both cases, the connection object can be used with the <code>erase</code> member function:</p>
<div class="fragment"><div class="line">emitter.erase(conn);</div></div><!-- fragment --><p>There are also two member functions to use either to disconnect all the listeners for a given type of event or to clear the emitter:</p>
<div class="fragment"><div class="line"><span class="comment">// removes all the listener for the specific event</span></div><div class="line">emitter.clear&lt;MyEvent&gt;();</div><div class="line"></div><div class="line"><span class="comment">// removes all the listeners registered so far</span></div><div class="line">emitter.clear();</div></div><!-- fragment --><p>To send an event to all the listeners that are interested in it, the <code>publish</code> member function offers a convenient approach that relieves users from having to create the event:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyEvent { <span class="keywordtype">int</span> i; };</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">emitter.publish&lt;MyEvent&gt;(42);</div></div><!-- fragment --><p>Finally, the <code>empty</code> member function tests if there exists at least either a listener registered with the event emitter or to a given type of event:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> empty;</div><div class="line"></div><div class="line"><span class="comment">// checks if there is any listener registered for the specific event</span></div><div class="line">empty = emitter.empty&lt;MyEvent&gt;();</div><div class="line"></div><div class="line"><span class="comment">// checks it there are listeners registered with the event emitter</span></div><div class="line">empty = emitter.empty();</div></div><!-- fragment --><p>In general, the event emitter is a handy tool when the derived classes <em>wrap</em> asynchronous operations, because it introduces a <em>nice-to-have</em> model based on events and listeners that kindly hides the complexity behind the scenes. However it is not limited to such uses. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
