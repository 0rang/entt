<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt::sparse_set&lt; Entity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceentt.html">entt</a></li><li class="navelem"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classentt_1_1sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">entt::sparse_set&lt; Entity &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="classentt_1_1sparse__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::sparse_set&lt; Entity &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classentt_1_1sparse__set__inherit__graph.png" border="0" usemap="#entt_1_1sparse__set_3_01Entity_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="entt_1_1sparse__set_3_01Entity_01_4_inherit__map" id="entt_1_1sparse__set_3_01Entity_01_4_inherit__map">
<area shape="rect" title="Basic sparse set implementation." alt="" coords="5,111,180,138"/>
<area shape="rect" href="classentt_1_1basic__storage.html" title=" " alt="" coords="251,5,405,47"/>
<area shape="rect" href="classentt_1_1basic__storage.html" title=" " alt="" coords="251,71,405,112"/>
<area shape="rect" href="classentt_1_1basic__storage.html" title="Basic storage implementation." alt="" coords="261,136,395,177"/>
<area shape="rect" href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01std_1_1enable__if__t_3_01ENTT__ENABLE__ETO_07Type_08_4_01_4.html" title="Basic storage implementation." alt="" coords="228,201,428,272"/>
<area shape="rect" href="structentt_1_1storage.html" title=" " alt="" coords="476,5,621,47"/>
<area shape="rect" href="structentt_1_1storage.html" title="Basic storage implementation." alt="" coords="476,136,621,177"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a1dbe5ab2dbb098beae0bff56bbf780"><td class="memItemLeft" align="right" valign="top"><a id="a9a1dbe5ab2dbb098beae0bff56bbf780"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> = Entity</td></tr>
<tr class="memdesc:a9a1dbe5ab2dbb098beae0bff56bbf780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier. <br /></td></tr>
<tr class="separator:a9a1dbe5ab2dbb098beae0bff56bbf780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2138b0eb8c7ac968e9e38a9e981ec1"><td class="memItemLeft" align="right" valign="top"><a id="a3d2138b0eb8c7ac968e9e38a9e981ec1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a3d2138b0eb8c7ac968e9e38a9e981ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:a3d2138b0eb8c7ac968e9e38a9e981ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580b210d5a24c49ca8c255646f3bb469"><td class="memItemLeft" align="right" valign="top"><a id="a580b210d5a24c49ca8c255646f3bb469"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> = iterator</td></tr>
<tr class="memdesc:a580b210d5a24c49ca8c255646f3bb469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type. <br /></td></tr>
<tr class="separator:a580b210d5a24c49ca8c255646f3bb469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8ef544aaed30126797f6f0b9a9f8b9e8"><td class="memItemLeft" align="right" valign="top"><a id="a8ef544aaed30126797f6f0b9a9f8b9e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a8ef544aaed30126797f6f0b9a9f8b9e8">sparse_set</a> ()=default</td></tr>
<tr class="memdesc:a8ef544aaed30126797f6f0b9a9f8b9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a8ef544aaed30126797f6f0b9a9f8b9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684a44e129f3aafd311814b5972378f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#af684a44e129f3aafd311814b5972378f">sparse_set</a> (const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:af684a44e129f3aafd311814b5972378f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classentt_1_1sparse__set.html#af684a44e129f3aafd311814b5972378f">More...</a><br /></td></tr>
<tr class="separator:af684a44e129f3aafd311814b5972378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4f137b5ac0984599067d5408db5bf"><td class="memItemLeft" align="right" valign="top"><a id="af8f4f137b5ac0984599067d5408db5bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#af8f4f137b5ac0984599067d5408db5bf">sparse_set</a> (<a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:af8f4f137b5ac0984599067d5408db5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:af8f4f137b5ac0984599067d5408db5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c49e0d205b6240bf14ac3003cfcbd1"><td class="memItemLeft" align="right" valign="top"><a id="a74c49e0d205b6240bf14ac3003cfcbd1"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a74c49e0d205b6240bf14ac3003cfcbd1">~sparse_set</a> () ENTT_NOEXCEPT=default</td></tr>
<tr class="memdesc:a74c49e0d205b6240bf14ac3003cfcbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a74c49e0d205b6240bf14ac3003cfcbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a00ca96cc7e78089fb7120d144de34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a32a00ca96cc7e78089fb7120d144de34">operator=</a> (const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a32a00ca96cc7e78089fb7120d144de34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classentt_1_1sparse__set.html#a32a00ca96cc7e78089fb7120d144de34">More...</a><br /></td></tr>
<tr class="separator:a32a00ca96cc7e78089fb7120d144de34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb1c0bffe341b847537956075b398fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a7cb1c0bffe341b847537956075b398fa">operator=</a> (<a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a7cb1c0bffe341b847537956075b398fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator.  <a href="classentt_1_1sparse__set.html#a7cb1c0bffe341b847537956075b398fa">More...</a><br /></td></tr>
<tr class="separator:a7cb1c0bffe341b847537956075b398fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4b9dd989877bc333fdc455fcd068d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a8b4b9dd989877bc333fdc455fcd068d7">reserve</a> (const <a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> cap)</td></tr>
<tr class="memdesc:a8b4b9dd989877bc333fdc455fcd068d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a sparse set.  <a href="classentt_1_1sparse__set.html#a8b4b9dd989877bc333fdc455fcd068d7">More...</a><br /></td></tr>
<tr class="separator:a8b4b9dd989877bc333fdc455fcd068d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30267005e552fce0d2a9b4e4d70d6656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a30267005e552fce0d2a9b4e4d70d6656">capacity</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a30267005e552fce0d2a9b4e4d70d6656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a sparse set has currently allocated space for.  <a href="classentt_1_1sparse__set.html#a30267005e552fce0d2a9b4e4d70d6656">More...</a><br /></td></tr>
<tr class="separator:a30267005e552fce0d2a9b4e4d70d6656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f5d70148a149e4cbc485c7a7b00dda"><td class="memItemLeft" align="right" valign="top"><a id="a75f5d70148a149e4cbc485c7a7b00dda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a75f5d70148a149e4cbc485c7a7b00dda">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a75f5d70148a149e4cbc485c7a7b00dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity. <br /></td></tr>
<tr class="separator:a75f5d70148a149e4cbc485c7a7b00dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79345df59154e5ea9e58b7efa7ff8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#af79345df59154e5ea9e58b7efa7ff8f0">extent</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:af79345df59154e5ea9e58b7efa7ff8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <a href="classentt_1_1sparse__set.html#af79345df59154e5ea9e58b7efa7ff8f0">More...</a><br /></td></tr>
<tr class="separator:af79345df59154e5ea9e58b7efa7ff8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340dff7484f1e58feff58a5f0627e190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a340dff7484f1e58feff58a5f0627e190">size</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a340dff7484f1e58feff58a5f0627e190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <a href="classentt_1_1sparse__set.html#a340dff7484f1e58feff58a5f0627e190">More...</a><br /></td></tr>
<tr class="separator:a340dff7484f1e58feff58a5f0627e190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a16cb354a9ed5ded92b6edcddce15e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#ae1a16cb354a9ed5ded92b6edcddce15e">empty</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ae1a16cb354a9ed5ded92b6edcddce15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <a href="classentt_1_1sparse__set.html#ae1a16cb354a9ed5ded92b6edcddce15e">More...</a><br /></td></tr>
<tr class="separator:ae1a16cb354a9ed5ded92b6edcddce15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eafe4975271769b08fe7f7d4924992f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a2eafe4975271769b08fe7f7d4924992f">data</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a2eafe4975271769b08fe7f7d4924992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <a href="classentt_1_1sparse__set.html#a2eafe4975271769b08fe7f7d4924992f">More...</a><br /></td></tr>
<tr class="separator:a2eafe4975271769b08fe7f7d4924992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06743336f265989b48e106a3d3bd1562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a06743336f265989b48e106a3d3bd1562">begin</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a06743336f265989b48e106a3d3bd1562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="classentt_1_1sparse__set.html#a06743336f265989b48e106a3d3bd1562">More...</a><br /></td></tr>
<tr class="separator:a06743336f265989b48e106a3d3bd1562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d6c1288f673c6f92d2b1b028d6aa75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a69d6c1288f673c6f92d2b1b028d6aa75">end</a> () const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a69d6c1288f673c6f92d2b1b028d6aa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="classentt_1_1sparse__set.html#a69d6c1288f673c6f92d2b1b028d6aa75">More...</a><br /></td></tr>
<tr class="separator:a69d6c1288f673c6f92d2b1b028d6aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed57521bb3279b5ed3cd397b65abf01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a0ed57521bb3279b5ed3cd397b65abf01">find</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> entt) const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a0ed57521bb3279b5ed3cd397b65abf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <a href="classentt_1_1sparse__set.html#a0ed57521bb3279b5ed3cd397b65abf01">More...</a><br /></td></tr>
<tr class="separator:a0ed57521bb3279b5ed3cd397b65abf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4eb4faf1aa28d20717716bea7981f5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#af4eb4faf1aa28d20717716bea7981f5b">has</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> entt) const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:af4eb4faf1aa28d20717716bea7981f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <a href="classentt_1_1sparse__set.html#af4eb4faf1aa28d20717716bea7981f5b">More...</a><br /></td></tr>
<tr class="separator:af4eb4faf1aa28d20717716bea7981f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdea531952ca6857abdfddf7866b5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#afbdea531952ca6857abdfddf7866b5a2">index</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> entt) const ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:afbdea531952ca6857abdfddf7866b5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <a href="classentt_1_1sparse__set.html#afbdea531952ca6857abdfddf7866b5a2">More...</a><br /></td></tr>
<tr class="separator:afbdea531952ca6857abdfddf7866b5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d293b9bc7227de22c86722881083f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a4f6d293b9bc7227de22c86722881083f">construct</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> entt)</td></tr>
<tr class="memdesc:a4f6d293b9bc7227de22c86722881083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <a href="classentt_1_1sparse__set.html#a4f6d293b9bc7227de22c86722881083f">More...</a><br /></td></tr>
<tr class="separator:a4f6d293b9bc7227de22c86722881083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642460f7f0ca8e42220c43c785467063"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a642460f7f0ca8e42220c43c785467063"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a642460f7f0ca8e42220c43c785467063">batch</a> (It first, It last)</td></tr>
<tr class="memdesc:a642460f7f0ca8e42220c43c785467063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one or more entities to a sparse set.  <a href="classentt_1_1sparse__set.html#a642460f7f0ca8e42220c43c785467063">More...</a><br /></td></tr>
<tr class="separator:a642460f7f0ca8e42220c43c785467063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69719626bee1add76096046db86a170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#ab69719626bee1add76096046db86a170">destroy</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> entt)</td></tr>
<tr class="memdesc:ab69719626bee1add76096046db86a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set.  <a href="classentt_1_1sparse__set.html#ab69719626bee1add76096046db86a170">More...</a><br /></td></tr>
<tr class="separator:ab69719626bee1add76096046db86a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef14da059528647a5d72f2e2ce0d762"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a5ef14da059528647a5d72f2e2ce0d762">swap</a> (const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> lhs, const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a> rhs) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:a5ef14da059528647a5d72f2e2ce0d762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in the internal packed array.  <a href="classentt_1_1sparse__set.html#a5ef14da059528647a5d72f2e2ce0d762">More...</a><br /></td></tr>
<tr class="separator:a5ef14da059528647a5d72f2e2ce0d762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae939a408911c573256cf0299d76828"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:afae939a408911c573256cf0299d76828"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#afae939a408911c573256cf0299d76828">sort</a> (<a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> first, <a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> last, Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afae939a408911c573256cf0299d76828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort elements according to the given comparison function.  <a href="classentt_1_1sparse__set.html#afae939a408911c573256cf0299d76828">More...</a><br /></td></tr>
<tr class="separator:afae939a408911c573256cf0299d76828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b36afb6ae6f91d995ff259184d6515"><td class="memTemplParams" colspan="2">template&lt;typename Apply , typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a28b36afb6ae6f91d995ff259184d6515"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#a28b36afb6ae6f91d995ff259184d6515">arrange</a> (<a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> first, <a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> last, Apply apply, Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a28b36afb6ae6f91d995ff259184d6515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort elements according to the given comparison function.  <a href="classentt_1_1sparse__set.html#a28b36afb6ae6f91d995ff259184d6515">More...</a><br /></td></tr>
<tr class="separator:a28b36afb6ae6f91d995ff259184d6515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0481dde89f07e9ca50d79777de898b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#ab0481dde89f07e9ca50d79777de898b6">respect</a> (const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> &amp;other) ENTT_NOEXCEPT</td></tr>
<tr class="memdesc:ab0481dde89f07e9ca50d79777de898b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in another sparse set.  <a href="classentt_1_1sparse__set.html#ab0481dde89f07e9ca50d79777de898b6">More...</a><br /></td></tr>
<tr class="separator:ab0481dde89f07e9ca50d79777de898b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf1b927ccc18fba0fef178d168c1fa7"><td class="memItemLeft" align="right" valign="top"><a id="abcf1b927ccc18fba0fef178d168c1fa7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sparse__set.html#abcf1b927ccc18fba0fef178d168c1fa7">reset</a> ()</td></tr>
<tr class="memdesc:abcf1b927ccc18fba0fef178d168c1fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a sparse set. <br /></td></tr>
<tr class="separator:abcf1b927ccc18fba0fef178d168c1fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Entity&gt;<br />
class entt::sparse_set&lt; Entity &gt;</h3>

<p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br  />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br  />
 This is largely used by the registry to offer users the fastest access ever to the components. Views and groups in general are almost entirely designed around sparse sets.</p>
<p>This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd>
<dd>
Internal data structures arrange elements to maximize performance. Because of that, there are no guarantees that elements have the expected order when iterate directly the internal packed array (see <code>data</code> and <code>size</code> member functions for that). Use <code>begin</code> and <code>end</code> instead.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00050">50</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af684a44e129f3aafd311814b5972378f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684a44e129f3aafd311814b5972378f">&#9670;&nbsp;</a></span>sparse_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::<a class="el" href="classentt_1_1sparse__set.html">sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to copy from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00191">191</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28b36afb6ae6f91d995ff259184d6515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b36afb6ae6f91d995ff259184d6515">&#9670;&nbsp;</a></span>arrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<div class="memtemplate">
template&lt;typename Apply , typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::arrange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Apply&#160;</td>
          <td class="paramname"><em>apply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort elements according to the given comparison function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1sparse__set.html#afae939a408911c573256cf0299d76828" title="Sort elements according to the given comparison function.">sort</a></dd></dl>
<p>This function is a slightly slower version of <code>sort</code> that invokes the caller to indicate which entities are swapped.<br  />
 It's recommended when the caller wants to sort its own data structures to align them with the order induced in the sparse set.</p>
<p>The signature of the callback should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Apply</td><td>Type of function object to invoke to notify the caller. </td></tr>
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range to sort. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range to sort. </td></tr>
    <tr><td class="paramname">apply</td><td>A valid function object to use as a callback. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00562">562</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a642460f7f0ca8e42220c43c785467063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642460f7f0ca8e42220c43c785467063">&#9670;&nbsp;</a></span>batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::batch </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns one or more entities to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.<br  />
 An assertion will abort the execution at runtime in debug mode if the sparse set already contains the given entity.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00421">421</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a06743336f265989b48e106a3d3bd1562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06743336f265989b48e106a3d3bd1562">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>The returned iterator points to the first entity of the internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1sparse__set.html#a69d6c1288f673c6f92d2b1b028d6aa75" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Random access iterators stay true to the order imposed by a call to <code>respect</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00326">326</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a30267005e552fce0d2a9b4e4d70d6656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30267005e552fce0d2a9b4e4d70d6656">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a sparse set has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00243">243</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a4f6d293b9bc7227de22c86722881083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6d293b9bc7227de22c86722881083f">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.<br  />
 An assertion will abort the execution at runtime in debug mode if the sparse set already contains the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00399">399</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2eafe4975271769b08fe7f7d4924992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eafe4975271769b08fe7f7d4924992f">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>* <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<p>The returned pointer is such that range <code>[<a class="el" href="classentt_1_1sparse__set.html#a2eafe4975271769b08fe7f7d4924992f" title="Direct access to the internal packed array.">data()</a>, <a class="el" href="classentt_1_1sparse__set.html#a2eafe4975271769b08fe7f7d4924992f" title="Direct access to the internal packed array.">data()</a> + <a class="el" href="classentt_1_1sparse__set.html#a340dff7484f1e58feff58a5f0627e190" title="Returns the number of elements in a sparse set.">size()</a>]</code> is always a valid range, even if the container is empty.</p>
<dl class="section note"><dt>Note</dt><dd>There are no guarantees on the order, even though <code>respect</code> has been previously invoked. Internal data structures arrange elements to maximize performance. Accessing them directly gives a performance boost but less guarantees. Use <code>begin</code> and <code>end</code> if you want to iterate the sparse set in the expected order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00309">309</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab69719626bee1add76096046db86a170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69719626bee1add76096046db86a170">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to remove an entity that doesn't belong to the sparse set results in undefined behavior.<br  />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00443">443</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ae1a16cb354a9ed5ded92b6edcddce15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a16cb354a9ed5ded92b6edcddce15e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00290">290</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a69d6c1288f673c6f92d2b1b028d6aa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d6c1288f673c6f92d2b1b028d6aa75">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p>The returned iterator points to the element following the last entity in the internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section note"><dt>Note</dt><dd>Random access iterators stay true to the order imposed by a call to <code>respect</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00345">345</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af79345df59154e5ea9e58b7efa7ff8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79345df59154e5ea9e58b7efa7ff8f0">&#9670;&nbsp;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::extent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of a sparse set. </p>
<p>The extent of a sparse set is also the size of the internal sparse array. There is no guarantee that the internal packed array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Extent of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00268">268</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0ed57521bb3279b5ed3cd397b65abf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed57521bb3279b5ed3cd397b65abf01">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the given entity if it's found, past the end iterator otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00355">355</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af4eb4faf1aa28d20717716bea7981f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4eb4faf1aa28d20717716bea7981f5b">&#9670;&nbsp;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00364">364</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="afbdea531952ca6857abdfddf7866b5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdea531952ca6857abdfddf7866b5a2">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.<br  />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00382">382</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a32a00ca96cc7e78089fb7120d144de34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a00ca96cc7e78089fb7120d144de34">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&amp; <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00214">214</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a7cb1c0bffe341b847537956075b398fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb1c0bffe341b847537956075b398fa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&amp; <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&lt; Entity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

</div>
</div>
<a id="a8b4b9dd989877bc333fdc455fcd068d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4b9dd989877bc333fdc455fcd068d7">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a sparse set. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00234">234</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab0481dde89f07e9ca50d79777de898b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0481dde89f07e9ca50d79777de898b6">&#9670;&nbsp;</a></span>respect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::respect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html">sparse_set</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in another sparse set. </p>
<p>Entities that are part of both the sparse sets are ordered internally according to the order they have in <code>other</code>. All the other entities goes to the end of the list and there are no guarantees on their order.<br  />
 In other terms, this function can be used to impose the same order on two sets by using one of them as a master and the other one as a slave.</p>
<p>Iterating the sparse set with a couple of iterators returns elements in the expected order after a call to <code>respect</code>. See <code>begin</code> and <code>end</code> for more details.</p>
<dl class="section note"><dt>Note</dt><dd>Attempting to iterate elements using a raw pointer returned by a call to <code>data</code> gives no guarantees on the order, even though <code>respect</code> has been invoked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00608">608</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a340dff7484f1e58feff58a5f0627e190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340dff7484f1e58feff58a5f0627e190">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sparse__set.html#a3d2138b0eb8c7ac968e9e38a9e981ec1">size_type</a> <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00282">282</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="afae939a408911c573256cf0299d76828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae939a408911c573256cf0299d76828">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1sparse__set.html#a580b210d5a24c49ca8c255646f3bb469">iterator_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort elements according to the given comparison function. </p>
<p>Sort the elements so that iterating the range with a couple of iterators returns them in the expected order. See <code>begin</code> and <code>end</code> for more details.</p>
<p>The comparison function object must return <code>true</code> if the first element is <em>less</em> than the second one, <code>false</code> otherwise. The signature of the comparison function should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><p>Moreover, the comparison function object shall induce a <em>strict weak ordering</em> on the values.</p>
<p>The sort function oject must offer a member function template <code>operator()</code> that accepts three arguments:</p>
<ul>
<li>An iterator to the first element of the range to sort.</li>
<li>An iterator past the last element of the range to sort.</li>
<li>A comparison function to use to compare the elements.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Attempting to iterate elements using a raw pointer returned by a call to <code>data</code> gives no guarantees on the order, even though <code>sort</code> has been invoked.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range to sort. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00517">517</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a5ef14da059528647a5d72f2e2ce0d762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef14da059528647a5d72f2e2ce0d762">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1sparse__set.html">entt::sparse_set</a>&lt; Entity &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1sparse__set.html#a9a1dbe5ab2dbb098beae0bff56bbf780">entity_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in the internal packed array. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.<br  />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entities.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a35f98e0151152bbf10fd1666f4bcf00b">entt::basic_storage&lt; Entity, Type, typename &gt;</a>, <a class="el" href="classentt_1_1basic__storage.html#a35f98e0151152bbf10fd1666f4bcf00b">entt::basic_storage&lt; Entity, Type &gt;</a>, <a class="el" href="classentt_1_1basic__storage.html#a35f98e0151152bbf10fd1666f4bcf00b">entt::basic_storage&lt; Entity, Component &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#a35f98e0151152bbf10fd1666f4bcf00b">entt::basic_storage&lt; entity_type, payload_type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00468">468</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/entt/entity/<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
