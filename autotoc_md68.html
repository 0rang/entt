<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Crash Course: runtime reflection system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Crash Course: runtime reflection system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md69"></a>
Introduction</h1>
<p>Reflection (or rather, its lack) is a trending topic in the C++ world and, in the specific case of <code>EnTT</code>, a tool that can unlock a lot of other features. I looked for a third-party library that met my needs on the subject, but I always came across some details that I didn't like: macros, being intrusive, too many allocations. In one word: unsatisfactory.<br />
 I finally decided to write a built-in, non-intrusive and macro-free runtime reflection system for <code>EnTT</code>. Maybe I didn't do better than others or maybe yes, time will tell me, but at least I can model this tool around the library to which it belongs and not vice versa.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Names and identifiers</h1>
<p>The meta system doesn't force the user to use the tools provided by the library when it comes to working with names and identifiers. It does this by offering an API that works with opaque identifiers that may or may not be generated by means of a hashed string.<br />
 This means that users can assign any type of identifier to the meta objects, as long as they are numeric. It doesn't matter if they are generated at runtime, at compile-time or with custom functions.</p>
<p>However, the examples in the following sections are all based on the <code>hashed_string</code> class as provided by this library. Therefore, where an identifier is required, it's likely that a user defined literal is used as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div></div><!-- fragment --><p>For what it's worth, this is likely completely equivalent to:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::reflect&lt;my_type&gt;(42);</div></div><!-- fragment --><p>Obviously, human-readable identifiers are more convenient to use and highly recommended.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Reflection in a nutshell</h1>
<p>Reflection always starts from real types (users cannot reflect imaginary types and it would not make much sense, we wouldn't be talking about reflection anymore).<br />
 To <em>reflect</em> a type, the library provides the <code>reflect</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div></div><!-- fragment --><p>It accepts the type to reflect as a template parameter and an optional identifier as an argument. Identifiers are important because users can retrieve meta types at runtime by searching for them by <em>name</em>. However, there are cases in which users can be interested in adding features to a reflected type so that the reflection system can use it correctly under the hood, but they don't want to allow searching the type by <em>name</em>.<br />
 In both cases, the returned value is a factory object to use to continue building the meta type.</p>
<p>A factory is such that all its member functions returns the factory itself. It can be used to extend the reflected type and add the following:</p>
<ul>
<li><em>Constructors</em>. Actual constructors can be assigned to a reflected type by specifying their list of arguments. Free functions (namely, factories) can be used as well, as long as the return type is the expected one. From a client's point of view, nothing changes if a constructor is a free function or an actual constructor.<br />
 Use the <code>ctor</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs).ctor&lt;int, char&gt;().ctor&lt;&amp;factory&gt;();</div></div><!-- fragment --><ul>
<li><em>Destructors</em>. Free functions can be set as destructors of reflected types. The purpose is to give users the ability to free up resources that require special treatment before an object is actually destroyed.<br />
 Use the <code>dtor</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs).dtor&lt;&amp;destroy&gt;();</div></div><!-- fragment --><p>A function should neither delete nor explicitly invoke the destructor of a given instance.</p>
<ul>
<li><em>Data members</em>. Both real data members of the underlying type and static and global variables, as well as constants of any kind, can be attached to a meta type. From a client's point of view, all the variables associated with the reflected type will appear as if they were part of the type itself.<br />
 Use the <code>data</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs)</div><div class="line">    .data&lt;&amp;my_type::static_variable&gt;(<span class="stringliteral">&quot;static&quot;</span>_hs)</div><div class="line">    .data&lt;&amp;my_type::data_member&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs)</div><div class="line">    .data&lt;&amp;global_variable&gt;(<span class="stringliteral">&quot;global&quot;</span>_hs);</div></div><!-- fragment --><p>This function requires as an argument the identifier to give to the meta data once created. Users can then access meta data at runtime by searching for them by <em>name</em>.<br />
 Data members can be set also by means of a couple of functions, namely a setter and a getter. Setters and getters can be either free functions, member functions or mixed ones, as long as they respect the required signatures.<br />
 Refer to the inline documentation for all the details.</p>
<ul>
<li><em>Member functions</em>. Both real member functions of the underlying type and free functions can be attached to a meta type. From a client's point of view, all the functions associated with the reflected type will appear as if they were part of the type itself.<br />
 Use the <code>func</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs)</div><div class="line">    .func&lt;&amp;my_type::static_function&gt;(<span class="stringliteral">&quot;static&quot;</span>_hs)</div><div class="line">    .func&lt;&amp;my_type::member_function&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs)</div><div class="line">    .func&lt;&amp;free_function&gt;(<span class="stringliteral">&quot;free&quot;</span>_hs);</div></div><!-- fragment --><p>This function requires as an argument the identifier to give to the meta function once created. Users can then access meta functions at runtime by searching for them by <em>name</em>.</p>
<ul>
<li><em>Base classes</em>. A base class is such that the underlying type is actually derived from it. In this case, the reflection system tracks the relationship and allows for implicit casts at runtime when required.<br />
 Use the <code>base</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;derived_type&gt;(<span class="stringliteral">&quot;derived&quot;</span>_hs).base&lt;base_type&gt;();</div></div><!-- fragment --><p>From now on, wherever a <code>base_type</code> is required, an instance of <code>derived_type</code> will also be accepted.</p>
<ul>
<li><em>Conversion functions</em>. Actual types can be converted, this is a fact. Just think of the relationship between a <code>double</code> and an <code>int</code> to see it. Similar to bases, conversion functions allow users to define conversions that will be implicitly performed by the reflection system when required.<br />
 Use the <code>conv</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;double&gt;().conv&lt;int&gt;();</div></div><!-- fragment --><p>That's all, everything users need to create meta types and enjoy the reflection system. At first glance it may not seem that much, but users usually learn to appreciate it over time.<br />
 Also, do not forget what these few lines hide under the hood: a built-in, non-intrusive and macro-free system for reflection in C++. Features that are definitely worth the price, at least for me.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Any as in any type</h2>
<p>The reflection system comes with its own meta any type. It may seem redundant since C++17 introduced <code>std::any</code>, but it is not.<br />
 In fact, the <em>type</em> returned by an <code>std::any</code> is a const reference to an <code>std::type_info</code>, an implementation defined class that's not something everyone wants to see in a software. Furthermore, the class <code>std::type_info</code> suffers from some design flaws and there is even no way to <em>convert</em> an <code>std::type_info</code> into a meta type, thus linking the two worlds.</p>
<p>A meta any object provides an API similar to that of its most famous counterpart and serves the same purpose of being an opaque container for any type of value.<br />
 It minimizes the allocations required, which are almost absent thanks to <em>SBO</em> techniques. In fact, unless users deal with <em>fat types</em> and create instances of them though the reflection system, allocations are at zero.</p>
<p>A meta any object can be created by any other object or as an empty container to initialize later:</p>
<div class="fragment"><div class="line"><span class="comment">// a meta any object that contains an int</span></div><div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> any{0};</div><div class="line"></div><div class="line"><span class="comment">// an empty meta any object</span></div><div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> empty{};</div></div><!-- fragment --><p>It takes the burden of destroying the contained instance when required.<br />
 Moreover, it can be used as an opaque container for unmanaged objects if needed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value;</div><div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> any{<a class="code" href="namespaceentt.html#abb24e649324b83ebcf9dea9c970b1e2d">entt::as_alias</a>, value};</div></div><!-- fragment --><p>In this case, the contained instance is never destroyed and users must ensure that the lifetime of the object exceeds that of the container.</p>
<p>A meta any object has a <code>type</code> member function that returns the meta type of the contained value, if any. The member functions <code>try_cast</code>, <code>cast</code> and <code>convert</code> are used to know if the underlying object has a given type as a base or if it can be converted implicitly to it.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Enjoy the runtime</h2>
<p>Once the web of reflected types has been constructed, it's a matter of using it at runtime where required.<br />
 All this has the great merit that, unlike the vast majority of the things present in this library and closely linked to the compile-time, the reflection system stands in fact as a non-intrusive tool for the runtime.</p>
<p>To search for a reflected type there are two options: by type or by <em>name</em>. In both cases, the search can be done by means of the <code>resolve</code> function:</p>
<div class="fragment"><div class="line"><span class="comment">// search for a reflected type by type</span></div><div class="line"><span class="keyword">auto</span> by_type = entt::resolve&lt;my_type&gt;();</div><div class="line"></div><div class="line"><span class="comment">// search for a reflected type by name</span></div><div class="line"><span class="keyword">auto</span> by_name = <a class="code" href="namespaceentt.html#a2129cb8668f5dcbc11854be6a4a0b6e5">entt::resolve</a>(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div></div><!-- fragment --><p>There exits also a third overload of the <code>resolve</code> function to use to iterate all the reflected types at once:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceentt.html#a2129cb8668f5dcbc11854be6a4a0b6e5">resolve</a>([](<span class="keyword">auto</span> type) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>In all cases, the returned value is an instance of <code>meta_type</code>. This type of objects offer an API to know the <em>runtime identifier</em> of the type, to iterate all the meta objects associated with them and even to build or destroy instances of the underlying type.<br />
 Refer to the inline documentation for all the details.</p>
<p>The meta objects that compose a meta type are accessed in the following ways:</p>
<ul>
<li><em>Meta constructors</em>. They are accessed by types of arguments:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ctor = entt::resolve&lt;my_type&gt;().ctor&lt;int, char&gt;();</div></div><!-- fragment --><p>The returned type is <code>meta_ctor</code> and may be invalid if there is no constructor that accepts the supplied arguments or at least some types from which they are derived or to which they can be converted.<br />
 A meta constructor offers an API to know the number of arguments, the expected meta types and to invoke it, therefore to construct a new instance of the underlying type.</p>
<ul>
<li><em>Meta destructor</em>. It's returned by a dedicated function:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> dtor = entt::resolve&lt;my_type&gt;().dtor();</div></div><!-- fragment --><p>The returned type is <code>meta_dtor</code> and may be invalid if there is no custom destructor set for the given meta type.<br />
 All what a meta destructor has to offer is a way to invoke it on a given instance. Be aware that the result may not be what is expected.</p>
<ul>
<li><em>Meta data</em>. They are accessed by <em>name</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> data = entt::resolve&lt;my_type&gt;().data(<span class="stringliteral">&quot;member&quot;</span>_hs);</div></div><!-- fragment --><p>The returned type is <code>meta_data</code> and may be invalid if there is no meta data object associated with the given identifier.<br />
 A meta data object offers an API to query the underlying type (ie to know if it's a const or a static one), to get the meta type of the variable and to set or get the contained value.</p>
<ul>
<li><em>Meta functions</em>. They are accessed by <em>name</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> func = entt::resolve&lt;my_type&gt;().func(<span class="stringliteral">&quot;member&quot;</span>_hs);</div></div><!-- fragment --><p>The returned type is <code>meta_func</code> and may be invalid if there is no meta function object associated with the given identifier.<br />
 A meta function object offers an API to query the underlying type (ie to know if it's a const or a static function), to know the number of arguments, the meta return type and the meta types of the parameters. In addition, a meta function object can be used to invoke the underlying function and then get the return value in the form of meta any object.</p>
<ul>
<li><em>Meta bases</em>. They are accessed through the <em>name</em> of the base types:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> base = entt::resolve&lt;derived_type&gt;().base(<span class="stringliteral">&quot;base&quot;</span>_hs);</div></div><!-- fragment --><p>The returned type is <code>meta_base</code> and may be invalid if there is no meta base object associated with the given identifier.<br />
 Meta bases aren't meant to be used directly, even though they are freely accessible. They expose only a few methods to use to know the meta type of the base class and to convert a raw pointer between types.</p>
<ul>
<li><em>Meta conversion functions</em>. They are accessed by type:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> conv = entt::resolve&lt;double&gt;().conv&lt;int&gt;();</div></div><!-- fragment --><p>The returned type is <code>meta_conv</code> and may be invalid if there is no meta conversion function associated with the given type.<br />
 The meta conversion functions are as thin as the meta bases and with a very similar interface. The sole difference is that they return a newly created instance wrapped in a meta any object when they convert between different types.</p>
<p>All the objects thus obtained as well as the meta types can be explicitly converted to a boolean value to check if they are valid:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> func = entt::resolve&lt;my_type&gt;().func(<span class="stringliteral">&quot;member&quot;</span>_hs);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(func) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>Furthermore, all meta objects with the exception of meta destructors can be iterated through an overload that accepts a callback through which to return them. As an example:</p>
<div class="fragment"><div class="line">entt::resolve&lt;my_type&gt;().data([](<span class="keyword">auto</span> data) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>A meta type can also be used to <code>construct</code> or <code>destroy</code> actual instances of the underlying type.<br />
 In particular, the <code>construct</code> member function accepts a variable number of arguments and searches for a match. It returns a <code>meta_any</code> object that may or may not be initialized, depending on whether a suitable constructor has been found or not. On the other side, the <code>destroy</code> member function accepts instances of <code>meta_any</code> as well as actual objects by reference and invokes the registered destructor if any.<br />
 Be aware that the result of a call to <code>destroy</code> may not be what is expected. The purpose is to give users the ability to free up resources that require special treatment and <b>not</b> to actually destroy instances.</p>
<p>Meta types and meta objects in general contain much more than what is said: a plethora of functions in addition to those listed whose purposes and uses go unfortunately beyond the scope of this document.<br />
 I invite anyone interested in the subject to look at the code, experiment and read the official documentation to get the best out of this powerful tool.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Policies: the more, the less</h2>
<p>Policies are a kind of compile-time directives that can be used when recording reflection information.<br />
 Their purpose is to require slightly different behavior than the default in some specific cases. For example, when reading a given data member, its value is returned wrapped in a <code>meta_any</code> object which, by default, makes a copy of it. For large objects or if the caller wants to access the original instance, this behavior isn't desirable. Policies are there to offer a solution to this and other problems.</p>
<p>There are a few alternatives available at the moment:</p>
<ul>
<li>The <em>as-is</em> policy, associated with the type <code><a class="el" href="structentt_1_1as__is__t.html" title="Empty class type used to request the as-is policy. ">entt::as_is_t</a></code>.<br />
 This is the default policy. In general, it should never be used explicitly, since it's implicitly selected if no other policy is specified.<br />
 In this case, the return values of the functions as well as the properties exposed as data members are always returned by copy in a dedicated wrapper and therefore associated with their original meta types.</li>
<li><p class="startli">The <em>as-void</em> policy, associated with the type <code><a class="el" href="structentt_1_1as__void__t.html" title="Empty class type used to request the as void policy. ">entt::as_void_t</a></code>.<br />
 Its purpose is to discard the return value of a meta object, whatever it is, thus making it appear as if its type were <code>void</code>.<br />
 If the use with functions is obvious, it must be said that it's also possible to use this policy with constructors and data members. In the first case, the constructor will be invoked but the returned wrapper will actually be empty. In the second case, instead, the property will not be accessible for reading.</p>
<p class="startli">As an example of use:</p>
</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs)</div><div class="line">    .func&lt;&amp;my_type::member_function, entt::as_void_t&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs);</div></div><!-- fragment --><ul>
<li><p class="startli">The <em>as-alias</em> policy, associated with the type <code><a class="el" href="structentt_1_1as__alias__t.html" title="Empty class type used to request the as alias policy. ">entt::as_alias_t</a></code>.<br />
 It allows to build wrappers that act as aliases for the objects used to initialize them. Modifying the object contained in the wrapper for which the <em>aliasing</em> was requested will make it possible to directly modify the instance used to initialize the wrapper itself.<br />
 This policy works with constructors (for example, when objects are taken from an external container rather than created on demand), data members and functions in general (as long as their return types are lvalue references).</p>
<p class="startli">As an example of use:</p>
</li>
</ul>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs)</div><div class="line">    .data&lt;&amp;my_type::data_member, entt::as_alias_t&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs);</div></div><!-- fragment --><p>Some uses are rather trivial, but it's useful to note that there are some less obvious corner cases that can in turn be solved with the use of policies.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Named constants and enums</h2>
<p>A special mention should be made for constant values and enums. It wouldn't be necessary, but it will help distracted readers.</p>
<p>As mentioned, the <code>data</code> member function can be used to reflect constants of any type among the other things.<br />
 This allows users to create meta types for enums that will work exactly like any other meta type built from a class. Similarly, arithmetic types can be enriched with constants of special meaning where required.<br />
 Personally, I find it very useful not to export what is the difference between enums and classes in C++ directly in the space of the reflected types.</p>
<p>All the values thus exported will appear to users as if they were constant data members of the reflected types.</p>
<p>Exporting constant values or elements from an enum is as simple as ever:</p>
<div class="fragment"><div class="line">entt::reflect&lt;my_enum&gt;()</div><div class="line">        .data&lt;my_enum::a_value&gt;(<span class="stringliteral">&quot;a_value&quot;</span>_hs)</div><div class="line">        .data&lt;my_enum::another_value&gt;(<span class="stringliteral">&quot;another_value&quot;</span>_hs);</div><div class="line"></div><div class="line">entt::reflect&lt;int&gt;().data&lt;2048&gt;(<span class="stringliteral">&quot;max_int&quot;</span>_hs);</div></div><!-- fragment --><p>It goes without saying that accessing them is trivial as well. It's a matter of doing the following, as with any other data member of a meta type:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> value = entt::resolve&lt;my_enum&gt;().data(<span class="stringliteral">&quot;a_value&quot;</span>_hs).get({}).cast&lt;my_enum&gt;();</div><div class="line"><span class="keyword">auto</span> max = entt::resolve&lt;int&gt;().data(<span class="stringliteral">&quot;max_int&quot;</span>_hs).get({}).cast&lt;int&gt;();</div></div><!-- fragment --><p>As a side note, remember that all this happens behind the scenes without any allocation because of the small object optimization performed by the meta any class.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Properties and meta objects</h2>
<p>Sometimes (for example, when it comes to creating an editor) it might be useful to be able to attach properties to the meta objects created. Fortunately, this is possible for most of them.<br />
 To attach a property to a meta object, no matter what as long as it supports properties, it is sufficient to provide an object at the time of construction such that <code>std::get&lt;0&gt;</code> and <code>std::get&lt;1&gt;</code> are valid for it. In other terms, the properties are nothing more than key/value pairs users can put in an <code>std::pair</code>. As an example:</p>
<div class="fragment"><div class="line">entt::reflect&lt;my_type&gt;(<span class="stringliteral">&quot;reflected&quot;</span>_hs, std::make_pair(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;message&quot;</span>));</div></div><!-- fragment --><p>The meta objects that support properties offer then a couple of member functions named <code>prop</code> to iterate them at once and to search a specific property by key:</p>
<div class="fragment"><div class="line"><span class="comment">// iterate all the properties of a meta type</span></div><div class="line">entt::resolve&lt;my_type&gt;().prop([](<span class="keyword">auto</span> prop) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// search for a given property by name</span></div><div class="line"><span class="keyword">auto</span> prop = entt::resolve&lt;my_type&gt;().prop(<span class="stringliteral">&quot;tooltip&quot;</span>_hs);</div></div><!-- fragment --><p>Meta properties are objects having a fairly poor interface, all in all. They only provide the <code>key</code> and the <code>value</code> member functions to be used to retrieve the key and the value contained in the form of meta any objects, respectively.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
Unregister types</h2>
<p>A type registered with the reflection system can also be unregistered. This means unregistering all its data members, member functions, conversion functions and so on. However, the base classes won't be unregistered, since they don't necessarily depend on it. Similarly, implicitly generated types (as an example, the meta types implicitly generated for function parameters when needed) won't be unregistered.</p>
<p>To unregister a type, users can use the <code>unregister</code> function from the global namespace:</p>
<div class="fragment"><div class="line">entt::unregister&lt;my_type&gt;();</div></div><!-- fragment --><p>This function returns a boolean value that is true if the type is actually registered with the reflection system, false otherwise.<br />
 The type can be re-registered later with a completely different name and form. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
