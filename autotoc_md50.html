<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Push EnTT across boundaries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Push EnTT across boundaries </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md51"></a>
Introduction</h1>
<p><code>EnTT</code> has historically had a limit when used across boundaries on Windows in general and on GNU/Linux when default visibility was set to <em>hidden</em>. The limitation is due mainly to a custom utility used to assign unique, sequential identifiers to different types. Unfortunately, this tool is used by several core classes (the <code>registry</code> among the others) that are thus almost unusable across boundaries.<br />
 The reasons for that are beyond the purposes of this document. However, the good news is that <code>EnTT</code> also offers now a way to overcome this limit and to push things across boundaries without problems when needed.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Named types and traits class</h1>
<p>To allow a type to work properly across boundaries when used by a class that requires to assign unique identifiers to types, users must specialize a class template to literally give a compile-time name to the type itself.<br />
 The name of the class template is <code>name_type_traits</code> and the specialization must be such that it exposes a static constexpr data member named <code>value</code> having type either <code>ENTT_ID_TYPE</code> or <code><a class="el" href="classentt_1_1hashed__string.html#a71cb1793c1193bd6c89c42a00179793f" title="Unsigned integer type. ">entt::hashed_string::hash_type</a></code>. Its value is the user defined unique identifier assigned to the specific type.<br />
 Identifiers are not to be sequentially generated in this case.</p>
<p>As an example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_type { <span class="comment">/* ... */</span> };</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span><a class="code" href="structentt_1_1named__type__traits.html">entt::named_type_traits</a>&lt;my_type&gt; {</div><div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> value = <span class="stringliteral">&quot;my_type&quot;</span>_hs;</div><div class="line">};</div></div><!-- fragment --><p>Because of the rules of the language, the specialization must reside in the global namespace or in the <code>entt</code> namespace. There is no way to change this rule unfortunately, because it doesn't depend on the library itself.</p>
<p>The good aspect of this approach is that it's not intrusive at all. The other way around was in fact forcing users to inherit all their classes from a common base. Something to avoid, at least from my point of view.<br />
 However, despite the fact that it's not intrusive, it would be great if it was also easier to use and a bit less error-prone. This is why a bunch of macros exist to ease defining named types.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Do not mix types</h2>
<p>Someone might think that this trick is valid only for the types to push across boundaries. This isn't how things work. In fact, the problem is more complex than that.<br />
 As a rule of thumb, users should never mix named and non-named types. Whenever a type is given a name, all the types must be given a name. As an example, consider the <code>registry</code> class template: in case it is pushed across boundaries, all the types of components should be assigned a name to avoid subtle bugs.</p>
<p>Indeed, this constraint can be relaxed in many cases. However, it is difficult to define a general rule to follow that is not the most stringent, unless users know exactly what they are doing. Therefore, I won't elaborate on giving further details on the topic.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Macros, macros everywhere</h1>
<p>The library comes with a set of predefined macros to use to declare named types or export already existing ones. In particular:</p>
<ul>
<li><code>ENTT_NAMED_TYPE</code> can be used to assign a name to already existing types. This macro must be used in the global namespace even when the types to be named are not.</li>
</ul>
<div class="fragment"><div class="line">ENTT_NAMED_TYPE(my_type)</div><div class="line">ENTT_NAMED_TYPE(ns::another_type)</div></div><!-- fragment --><ul>
<li><code>ENTT_NAMED_STRUCT</code> can be used to define and export a struct at the same time. It accepts also an optional namespace in which to define the given type. This macro must be used in the global namespace.</li>
</ul>
<div class="fragment"><div class="line">ENTT_NAMED_STRUCT(my_type, { <span class="comment">/* struct definition */</span>})</div><div class="line">ENTT_NAMED_STRUCT(ns, another_type, { <span class="comment">/* struct definition */</span>})</div></div><!-- fragment --><ul>
<li><code>ENTT_NAMED_CLASS</code> can be used to define and export a class at the same time. It accepts also an optional namespace in which to define the given type. This macro must be used in the global namespace.</li>
</ul>
<div class="fragment"><div class="line">ENTT_NAMED_CLASS(my_type, { <span class="comment">/* class definition */</span>})</div><div class="line">ENTT_NAMED_CLASS(ns, another_type, { <span class="comment">/* class definition */</span>})</div></div><!-- fragment --><p>Nested namespaces are supported out of the box as well in all cases. As an example:</p>
<div class="fragment"><div class="line">ENTT_NAMED_STRUCT(nested::ns, my_type, { <span class="comment">/* struct definition */</span>})</div></div><!-- fragment --><p>These macros can be used to avoid specializing the <code>named_type_traits</code> class template. In all cases, the name of the class is used also as a seed to generate the compile-time unique identifier.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Conflicts</h2>
<p>When using macros, unique identifiers are 32/64 bit integers generated by hashing strings during compilation. Therefore, conflicts are rare but still possible. In case of conflicts, everything simply will get broken at runtime and the strangest things will probably take place.<br />
 Unfortunately, there is no safe way to prevent it. If this happens, it will be enough to give a different value to one of the conflicting types to solve the problem. To do this, users can either assign a different name to the class or directly define a specialization for the <code>named_type_traits</code> class template.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Allocations: the dark side of the force</h1>
<p>As long as <code>EnTT</code> won't support custom allocators, another problem with allocations will remain alive instead. This is in fact easily solved, or at least it is if one knows it.</p>
<p>To allow users to add types dynamically, the library makes extensive use of type erasure techniques and dynamic allocations for pools (whether they are for components, events or anything else). The problem occurs when, for example, a registry is created on one side of a boundary and a pool is dynamically created on the other side. In the best case, everything will crash at the exit, while at worst it will do so at runtime.<br />
 To avoid problems, the pools must be generated from the same side of the boundary where the object that owns them is also created. As an example, when the registry is created in the main executable and used across boundaries for a given type of component, the pool for that type must be created before passing around the registry itself. To do this is fortunately quite easy, since it is sufficient to invoke any of the methods that involve the given type (continuing the example with the registry, a call to <code>reserve</code> or <code>size</code> is more than enough).</p>
<p>Maybe one day some dedicated methods will be added that do nothing but create a pool for a given type. Until now it has been preferred to keep the API cleaner as they are not strictly necessary. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
